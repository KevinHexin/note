1. 虚拟内存与分页系统
q: 为什么会有虚拟内存? (1.5章)
a: 
  1. 地址空间不隔离, 可能会遭受恶意程序对其他程序内存数据的修改
  2. 如果程序需要的内存空间是连续的, 当多个程序要运行但是空间不够时, 需要将一个已经运行的程序从内存换出到磁盘, 然后再换回来, 内存使用效率低下
  3. 程序的运行地址不确定, 导致访问一些固定数据和指令的目标地址不再是固定的
  4. 有虚拟地址空间后, 可以很好的做到程序地址空间的隔离, 程序在编写和编译、链接、执行等的过程中, 无需考虑实际地址空间不同程序占用的不同空间

q: 为什么会有内存分页? (1.5章)
a:
  1. 早期采用分段的做法, 即将程序所需要的整个虚拟地址空间全部映射到物理内存, 但是带来的问题是无法解决内存使用效率低下的问题
  2. 分页减小了内存映射的粒度, 且如果某块虚拟内存没有发生真正的读写操作, 则并引发缺页异常, 这样节省了物理内存空间
  3. 注意页也分为虚拟内存页, 物理内存页, 磁盘页 (1.5.3章)

2. ELF文件
q: ELF指哪些文件? (3.1章)
a:
  1. 可重定向文件(.o文件), 可执行文件, 共享目标文件(.so), 核心转储文件(core dump)

q: elf有哪些内容?
a:
  1. 文件头
  2. 段表(section)
  3. 重定位表(一般指data段和text段的重定位表)
  4. 字符串表
  5. 符号表(数据结构, 存储了符号名、长度和位置等信息)
  6. 调试信息

3. 静态链接与虚拟地址空间的确定
q: 静态链接的步骤? (4.1章)
a:
  1. 符号解析
    A. 编译器收集所有`引用符号`和`定义符号`(注意没有局部定义的符号)
    B. 将收集的信息存储到符号表中
    C. 链接器将每个引用的符号都与一个确定的符号定义建立关联
  2. 重定位
    A. 相似段合并, 将多个代码段与数据段合并为单独的段
    B. 确定每个`定义符号`在虚拟地址空间中的绝对地址, 完成后, 每条指令和每个全局或局部变量都可确定地址
    C. 将可执行文件中`引用符号`处的地址修改为重定位后的地址信息, 这时会用到text段和data段重定位表信息

q: 静态链接时如何确定可执行文件的符号(数据和函数)地址? (4.2章)
a: 
  1. 在文件链接之前, 目标文件(.o)各个段的虚拟空间起始地址是不确定的, 统一被设置为0 (4.1.2 清单4-1)
  2. 获得合并后各个段的长度与位置, 建立段与虚拟地址空间的映射关系, 这时段在虚拟地址空间的起始地址被确认
  3. 确定符号虚拟地址, 对于目标文件内固定偏移的符号, 使用段起始地址加上偏移地址即可得到符号地址 (4.1.3章)
  4. 确定符号虚拟地址, 对于目标文件引用的其它目标文件的符号, 需要读取重定位表 (4.2.2章)

4. 可执行文件的装载
q: 进程如何建立? (6.3.1章)
a:
  1. 创建一个独立的虚拟地址空间, 实际上是创建空间映射函数所需要的数据结构
  2. 读取可执行文件头部部分(header和段表, 3.4.1章), 建立虚拟空间与可执行文件的映射关系(实际上是在内核中建了一个映射表结构VMA)
  3. 将cpu指令寄存器设置成可执行文件入口(虚拟地址, 保存在可执行文件头中, 3.4.1章开头), 启动运行

q: 可执行文件如何装载?
a:
  1. 可执行文件各个段与虚拟地址空间建立映射关系后, 采用缺页异常和分页装载的方式将可执行文件装载到内存中

q: VMA是什么?
a:
  1. 虚拟内存区域(VMA)即操作系统管理的一个数据结构, 里面存储了对elf文件段映射的虚拟空间的地址范围, 以及段在ELF文件中的偏移
  2. VMA同时也用来对进程的虚拟地址空间进行管理(代码段, 数据段, 堆, 栈), 查看/proc可以看到进程的虚拟空间分布 (6.4.2章)

q: segment和section的区别?
a:
  1. segment是操作系统根据elf段的权限(可读, 可写, 可执行)来对段进行合并后的概念, 所以segment是装载时对elf的划分, section是文件状态对elf的划分
